%%% This file has -*- Erlang -*- syntax.

%% ===========================================================================
%% Configuration

%% These variables are used to generate the release file and boot script to
%% start RefactorErl. The startup script relies on the release name, so don't
%% change that. The version number should be updated when necessary.
RELEASE = "refactorerl".
VERSION = "0.9.12.04".

%% Flags used by the compiler
ErlFlags = [debug_info].


%% ===========================================================================
%% Description of targets
%%
%% tool    -- builds everything that is necessary to run the tool
%%              Included targets: builder
%%                                source
%%
%% doc     -- builds the API documentation
%%              Included targets: builder
%%                                source
%%
%% clean   -- removes every file that is generated by the build
%%
%% source  -- creates the complete source code, mainly by generating files
%%            which are to be generated
%%              Included targets: builder
%%
%% builder -- builds programs that are parts of the build system


%% ===========================================================================
%% Description of global rules
%%
%% erl  -- compiles and loads Erlang modules
%%           Input files: specified by #source.files
%%           Output dir: `ebin'
%%
%% yrl  -- generates Erlang code using yecc
%%           Input files: specified by #source.files
%%           Output dir: `src'
%%
%% xrl  -- generates Erlang code using leex
%%           Input files: specified by #source.files
%%           Output dir: `src'
%%
%% lex  -- generates a lexical analyser table using refgen_scanc
%%           Input files: specified by #source.files
%%           Output dir: `lex'
%%
%% app  -- generates application descriptors from .appspec files
%%           Input files: specified by #source.files
%%           Output dir: `ebin'
%%
%% rel  -- generates RELEASE.rel
%%           Input files: lib/*/ebin/*.app
%%           Output file: RELEASE.rel
%%
%% boot -- generates a boot script from a release file
%%           Input files: specified by #source.files (*.rel)
%%           Output dir: same as source
%%
%% doc  -- generated EDoc documentation for an application
%%           Input files: specified by #source.files (*.app)
%%           Output dir: `doc'
%%
%% eyrl  -- generates Erlang QC code using a generator generator
%%           Input files: specified by #source.files
%%           Output dir: `src'


%% ===========================================================================
%% Rules and targets

#rule{name   = erl,
      output = join("ebin", basename(File, ".erl")++".beam"),
      action =
        begin
            {ok, _} = compile:file(File, [report,
                                          {outdir, join(Dir, "ebin")},
                                          {i, join(Dir, "include")} |
                                          ErlFlags]),
            code:purge(list_to_atom(basename(File, ".erl"))),
            code:load_abs(join([Dir, "ebin", basename(File, ".erl")]))
        end,
      deps    =
        begin
            Path = [join(Dir, "include") | [Inc || {i, Inc} <- ErlFlags]],
            [{file, F} || F <- referl_gen_build:erl_includes(File, Path)]
        end}.

#rule{name = cpp_src,
      output = 
        begin
            Name = basename(File),
            SharedLibraryFile = 
                case os:type() of
                    {win32, _} -> string:join([Name, ".dll"],"");
                    {unix, _}  -> string:join([Name, ".so"],"")
                end,
            join("priv", SharedLibraryFile)
        end,
      action = 
        begin
            CompileNif        = list_to_atom(os:getenv("COMPILE_CPP")),
            CppCompiler       = os:getenv("CPP_COMPILER"),
            Name              = basename(File),
            BadmatchException = fun() -> 1 = 2 end,
            
            case {CompileNif, os:find_executable(CppCompiler)} of
            %% Warnings; No compilation!
            {true, false} ->
                io:format("Warning: No g++ compiler found!~n" ++
                          "The CPP code of ~s has not been compiled!~n", [Name]);
            {false, _} ->
                io:format("Warning: the CPP code of ~s has not been compiled!~n",
                          [Name]);

            %% If everything is ok, then compile.
            {true, _} ->
                CommonCppCompilerFlags = "-Wall -fPIC -O3",
                CppCompilerFlags  = 
                    case {os:type(), os:version()} of
                        {{unix, darwin}, _} ->
                            "-undefined dynamic_lookup -dynamiclib";
                        {{unix, sunos}, {5, Mi, _}} when Mi == 8; Mi == 9 ->
                            "-D__OLD_SOLARIS__ -shared";
                        _ ->
                            "-shared"
                    end ++ " " ++ CommonCppCompilerFlags,
                CppSources        = join([File, "src", "*.cpp"]),
                CppHeadersDir     = join([File, "include"]),
                ErlNifDirectory   = join([code:root_dir(), "usr", "include"]),
                SharedLibraryFile = 
                    case os:type() of
                        {win32, _} -> string:join([Name, ".dll"],"");
                        {unix , _} -> string:join([Name, ".so"],"")
                    end,
                SharedLibraryPath = join([Dir, "priv", SharedLibraryFile]),
                
                CompileCmd =
                    CppCompiler ++ " " ++ CppCompilerFlags ++ " " ++
                    CppSources  ++ " " ++
                    " -I " ++ CppHeadersDir ++ " -I " ++ ErlNifDirectory ++
                    " -o " ++ SharedLibraryPath,

                io:format("Compile command:~n~s~n",[CompileCmd]),
                case os:cmd(CompileCmd) of
                    ""         -> ok;
                    MaybeError ->
                        case string:str(MaybeError, "error:") of
                            0 ->
                                io:format("Build ended with warning(s):~n~s",
                                          [MaybeError]),
                                ok;
                            _ ->
                                io:format("Build ended with error(s):~n~s",
                                          [MaybeError]),
                                BadmatchException()
                        end
                end
          end
        end,
      deps = 
        begin
            DepFiles =
                filelib:wildcard(join([File, "src", "*.cpp"])) ++
                filelib:wildcard(join([File, "include", "*.h"])),
            [{file, F} || F <- DepFiles]
        end}.

#rule{name   = nitrogen_site,
      output = join("ebin", basename(File, ".erl")++".beam"),
      action =
        begin
            {ok, _} = compile:file(File, [report,
                                          {outdir, join(Dir, "ebin")},
                                          {i, join(Dir, "include")},
                                          {i, join(Dir,"../apps")} |
                                          ErlFlags]),
            code:purge(list_to_atom(basename(File, ".erl"))),
            code:load_abs(join([Dir, "ebin", basename(File, ".erl")]))
        end,
      deps    =
        begin
            Path = [join(Dir, "include") | [Inc || {i, Inc} <- ErlFlags]],
            [{file, F} || F <- referl_gen_build:erl_includes(File, Path)]
        end}.

#rule{name   = yaws,
      output = join("ebin", basename(File, ".erl")++".beam"),
      action =
        begin
            Yaws189 = list_to_atom(os:getenv("YAWS189")),
            YMacro = case Yaws189 of
            true -> YMacro = yaws189;
            false -> YMacro = yaws190
            end,
            {ok, _} = compile:file(File, [report,
                                          {outdir, join(Dir, "ebin")},
                                          {i, join(Dir, "include")},
                                          {d,YMacro, true} |
                                          ErlFlags]),
            code:purge(list_to_atom(basename(File, ".erl"))),
            code:load_abs(join([Dir, "ebin", basename(File, ".erl")]))
        end,
      deps    =
        begin
            Path = [join(Dir, "include") | [Inc || {i, Inc} <- ErlFlags]],
            [{file, F} || F <- referl_gen_build:erl_includes(File, Path)]
        end}.
        
#rule{name   = eyrl,
      output = join("src", basename(File,".eyrl")++".erl"),
      action = {ok,_}=egg:file(File, [verbose]),
      deps   = [{mod, egg}]}.

#rule{name   = yrl,
      output = join("src", basename(File,".yrl")++".erl"),
      action = {ok,_}=yecc:file(File, [verbose]),
      deps   = [{mod, yecc}]}.

#rule{name   = xrl,
      output = join("src", basename(File,".xrl")++".erl"),
      action = {ok,_}=leex:file(File, [verbose]),
      deps   = [{mod, leex}]}.

#rule{name   = lex,
      output = join("priv", basename(File)++".tab"),
      action = ok=refgen_scanc:file(
                    File,
                    [{output, join([Dir, "priv", basename(File)++".tab"])}]),
      deps   = [{mod, refgen_scanc}]}.

#rule{name   = app,
      output = join("ebin", basename(File, ".appspec")++".app"),
      action = %% This could be put into a module.
        begin
            {ok, Spec} = file:consult(File),
            App =
                {application, list_to_atom(basename(Dir)),
                 lists:map(
                   fun
                       ({modSrc, Mods}) ->
                           {modules,
                            [list_to_atom(basename(Src, ".erl")) ||
                                Src <- lists:append(
                                         [filelib:wildcard(
                                            join(dirname(File), Mod)) ||
                                             Mod <- Mods])]};
                       (Other) -> Other
                   end,
                   Spec)},
            ok = file:write_file(
                   join([Dir, "ebin", basename(File, ".appspec")++".app"]),
                   [io_lib:print(App), ".\n"])
        end}.

#rule{name   = rel,
      output = RELEASE ++ ".rel",
      action = %% This could also be put into a module.
        begin
            Apps = [list_to_atom(basename(App, ".app")) ||
                       App <- filelib:wildcard(
                                join([Dir, "lib", "*", "ebin", "*.app"]))],
            AllApps =
                [begin
                     application:load(App),
                     {ok, Deps} = application:get_key(App, applications),
                     [App | Deps]
                 end || App <- Apps],
            AppInfo =
                [begin
                     application:load(App),
                     {ok, Vsn} = application:get_key(App, vsn),
                     {App, Vsn}
                 end || App <- lists:usort(lists:flatten(AllApps))],
            Rel = {release,
                   {RELEASE, VERSION},
                   {erts, erlang:system_info(version)},
                   AppInfo},
            ok = file:write_file(join(Dir, RELEASE ++ ".rel"),
                                 [io_lib:print(Rel), ".\n"])
        end,
      deps   = [{file, App} ||
                   App <- filelib:wildcard(
                            join([Dir, "lib", "*", "ebin", "*.app"]))]}.

#rule{name   = boot,
      output = join(dirname(File), basename(File, ".rel")++".boot"),
      action = ok=systools:make_script(
                    join(dirname(File), basename(File, ".rel")),
                    [no_module_tests])}.

#rule{name   = doc,
      output = [join("doc", "index.html") |
                [join("doc", basename(F, ".erl") ++ ".html") ||
                    F <- filelib:wildcard(join([Dir, "src", "*.erl"]))]],
      action = try edoc:application(list_to_atom(basename(File, ".app"))) of
                   ok -> ok
               catch
                   exit:error -> erlang:error(edoc_error)
               end,
      deps   = [{file, join([Dir, "doc", "overview.edoc"])} |
                [{file, F} || F<-filelib:wildcard(join([Dir,"src","*.erl"]))]]}.



#target{name=source,
        rules=[#invoke{target=builder}]}.

#target{name=tool,
        rules=[#invoke{target=source}]}.

#target{name=doc,
        rules=[#invoke{target=source}]}.

#invoke{dir="lib"}.

#target{name=tool,
        rules=[#source{rule=rel},
               #source{files="refactorerl.rel", rule=boot}]}.

#target{name=clean,
        rules=[#apply{files=["refactorerl.*", "build.deps"],
                      action=file:delete(File)},
               exit(clear_deps)]}.
