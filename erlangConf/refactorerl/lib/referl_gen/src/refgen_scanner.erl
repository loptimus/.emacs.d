%%% -*- coding: latin-1 -*-

%%% The  contents of this  file are  subject to  the Erlang  Public License,
%%% Version  1.1, (the  "License");  you may  not  use this  file except  in
%%% compliance  with the License.  You should  have received  a copy  of the
%%% Erlang  Public License  along  with this  software.  If not,  it can  be
%%% retrieved at http://plc.inf.elte.hu/erlang/
%%%
%%% Software  distributed under  the License  is distributed  on an  "AS IS"
%%% basis, WITHOUT  WARRANTY OF ANY  KIND, either expressed or  implied. See
%%% the License  for the specific language governing  rights and limitations
%%% under the License.
%%%
%%% The Original Code is RefactorErl.
%%%
%%% The Initial Developer of the  Original Code is Eötvös Loránd University.
%%% Portions created  by Eötvös  Loránd University are  Copyright 2009,
%%% Eötvös Loránd University. All Rights Reserved.

%%% @doc Generic lexical scanner module. Works with state transition tables
%%% that are generated by {@link refgen_scanc}.
%%%
%%% === Mapping style scanner ===
%%%
%%% This mode is similar to calling `lists:map' on the list of input tokens
%%% with a user-supplied callback function. The input is split into tokens,
%%% the callback function is called with a single argument which described the
%%% token, and the return value of the scanned is the list of return values
%%% from the function calls.
%%%
%%% === Accumulator style scanner ===
%%%
%%% This mode is similar to calling `lists:foldl' on the list of input tokens.
%%% The user-supplied callback function has two arguments, the first describes
%%% the token, and the second is a user-supplied state data. Subsequent calls
%%% will get the return value of the previous call as state data, and finally,
%%% a separate function call is made which signals the end of the input. The
%%% return value of the scanner is the return value from the last function
%%% call.
%%%
%%% @author Laszlo Lovei <lovei@inf.elte.hu>

-module(refgen_scanner).
-vsn("$Rev: 3870 $").

%% Client exports
-export([new/1]).

%% =============================================================================
%% Implementation

%% @type map_scanner() = (string()) -> {ok, [term()]} | {error, pos(), char()}.
%% Type signature of mapping style scanners.
%%
%% @type map_callback() = (token()) -> term().
%% Type signature of callback functions for mapping style scanner.

%% @type fold_scanner() = (string(), term()) -> {ok, term()} |
%%                                              {error, pos(), char()}.
%% Type signature of accumulator style scanners.
%%
%% @type fold_callback() = (token(), term()) -> term().
%% Type signature of callback functions for accumulator style scanners.

%% @type token() = {Type::atom(), Text::string(), {Start::pos(), End::pos()}}.
%% Token information provided for the callback functions. `Start' is the
%% position of the first character of the token, `End' is the position right
%% after the last character of the token.

%% @type pos() = {Line::integer(), Column::integer()}. Position information
%% provided by the scanner. `Line' and `Column' values start from `0'.

%% @spec new([Opt]) -> map_scanner() | fold_scanner()
%% @doc Creates a new scanner function. `Opt' may be one of the following:
%%
%% <dl>
%%
%% <dt>`{file, File}'</dt> <dd>Read state transition table from `File'.
%%   Currently this option is mandatory (i.e. no other way to provide the
%%   table). </dd>
%%
%% <dt>`{callback, Fun}'</dt> <dd>`Fun' is the callback function which is
%%   called by the scanner for every token to calculate the result. The
%%   default is the identity function. The type signature of `Fun' may be
%%   {@type map_callback()}, in which case a {@type map_scanner()} type
%%   scanner is returned, or {@type fold_callback()}, in which case a {@type
%%   fold_scanner()} type scanner is returned.</dd>
%%
%% </dl>
new(Opts) ->
    Callback = proplists:get_value(callback, Opts, fun token_data/1),
    case get_table(Opts) of
        {ok, Table}     -> scanner(convert_dfa(Table), Callback);
        {error, Reason} -> throw(Reason)
    end.

get_table(Opts) ->
    case proplists:lookup(table, Opts) of
        {table, Table} -> {ok, Table};
        _ -> read_table(Opts)
    end.

read_table(Opts) ->
    {file, File} = proplists:lookup(file, Opts),
    case file:consult(File) of
        {ok, [Table]} -> {ok, Table};
        {error, Reason} -> {error, {File, file:format_error(Reason)}}
    end.


token_data(Token) ->
    Token.

scanner(DFA, Callback) ->
    case erlang:fun_info(Callback, arity) of
        {arity, 1} ->
            fun (String) -> string(String, Callback, DFA) end;
        {arity, 2} ->
            fun (String, Init) -> string(String, Callback, Init, DFA) end
    end.

convert_dfa(DFA) ->
    Acc = [{S,A} || {S, {_,A}} <- DFA],
    Trans = [list_to_tuple([action(Ch, Tr, Acc) || Ch <- lists:seq(0, 255)])
             || {_St, {Tr, _Acc}} <- lists:sort(DFA)],
    list_to_tuple(Trans).

action(Ch, Tr, Acc) ->
    case orddict:find(Ch, Tr) of
        {ok, To} ->
            {ok, A} = orddict:find(To, Acc),
            {To, A};
        error -> undefined
    end.

string(String, Callback, DFA) ->
    string(String, collect(Callback), [], DFA).

collect(Fun) ->
    fun
        ({eof, _}, Lst)   -> lists:reverse(Lst);
        (Token, Lst) -> [Fun(Token) | Lst]
    end.

string(String, Callback, State, DFA) ->
    string(String, {0,0}, Callback, State, DFA).

string("", Pos, Callback, State, _DFA) ->
    {ok, Callback({eof, Pos}, State)};
string(String, Start, Callback, State, DFA) ->
    case next_token(String, Start, 0, "", none, DFA) of
        {Type, Token, End, Rest} ->
            NextState = Callback({Type, Token, {Start, End}}, State),
            string(Rest, End, Callback, NextState, DFA);
        none ->
            {error, Start, hd(String)}
    end.

next_token("", _, _, _, Accept, _) ->
    accept(Accept);
next_token([Head|Tail], Pos, St, Token, Accept, DFA) ->
    Trans = element(St+1, DFA),
    case element(Head+1, Trans) of
        {NextSt, Acc} ->
            NewToken = [Head | Token],
            NextPos = next(Head, Pos),
            NewAccept =
                if
                    Acc =:= [] -> Accept;
                    true -> {Acc, NewToken, NextPos, Tail}
                end,
            next_token(Tail, NextPos, NextSt, NewToken, NewAccept, DFA);
        undefined ->
            accept(Accept)
    end.

accept({A, Tk, End, Tl}) -> {A, lists:reverse(Tk), End, Tl};
accept(Acc)         -> Acc.

next($\n, {Ln, _}) -> {Ln+1, 0};
next(_, {Ln, Col}) -> {Ln, Col+1}.
